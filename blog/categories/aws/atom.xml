<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aws | さよならインターネット]]></title>
  <link href="http://blog.kenjiskywalker.org/blog/categories/aws/atom.xml" rel="self"/>
  <link href="http://blog.kenjiskywalker.org/"/>
  <updated>2016-07-12T10:36:11+09:00</updated>
  <id>http://blog.kenjiskywalker.org/</id>
  <author>
    <name><![CDATA[kenjiskywalker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[特定のインスタンスIDのタグのValueを出力する]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2016/07/12/ec2-tag-describe-instances/"/>
    <updated>2016-07-12T10:31:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2016/07/12/ec2-tag-describe-instances</id>
    <content type="html"><![CDATA[<h3><code>query</code>オプションとかよー使わんわということで個人的メモ</h3>

<p><code>Name</code>タグを出力したければこう</p>

<pre><code>$ aws ec2 describe-instances \
          --instance-ids i-XXXXXXXX \
          --query 'Reservations[].Instances[].Tags[?Key==`Name`].Value' \
          --output text
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeDeployのfailをSlackに通知して原因までたどりやすくする]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2016/03/14/infrom-codedeploy-error-to-slack/"/>
    <updated>2016-03-14T11:03:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2016/03/14/infrom-codedeploy-error-to-slack</id>
    <content type="html"><![CDATA[<p><a href="https://aws.amazon.com/jp/about-aws/whats-new/2016/02/aws-codedeploy-adds-push-notification-support/">AWS CodeDeploy Adds Push Notification Support</a></p>

<p>ということで、これができるまではひたすらstate毎にslackに通知していたけど<br/>
failしたらfailしたよって通知するようにした。</p>

<p>流れ的にはこう</p>

<pre><code>CodeDeploy fail -&gt; AWS SNS -&gt; AWS Lambda -&gt; Slack
</code></pre>

<h2>やり方</h2>

<h3>AWS SNSで受け口をつくる</h3>

<p>CodeDeployがfailした歳に利用するSNSを用意する</p>

<ul>
<li>NotifyCodeDeployErrorToSlack</li>
</ul>


<p>みたいな感じで。開発環境やステージングなどでslackの通知グループが別れる場合は<br/>
都度SNSをつくっているんだけど、これもっと良いやり方ないのかな？</p>

<h3>CodeDeployのtriggerに先ほどつくったSNSを設定する</h3>

<p><img src="https://dl.dropboxusercontent.com/u/5390179/capture-CodeDeployTrigger.png" alt="https://dl.dropboxusercontent.com/u/5390179/capture-CodeDeployTrigger.png" /></p>

<p>fail以外にもステータスがあるのでそこでhookかけても良いですね。<br/>
自分のところはstate毎に通知させているので一旦この形です。</p>

<h3>AWS LambdaでSlackへの通知を行う</h3>

<ul>
<li>NotifyCodeDeployErrorToSlackFunction</li>
</ul>


<p>とか適当な名前でfunctionをつくる</p>

<pre><code class="js">// Ref: https://gist.github.com/vgeshel/1dba698aed9e8b39a464
console.log('Loading function');

const https = require('https');
const url = require('url');
// to get the slack hook url, go into slack admin and create a new "Incoming Webhook" integration
const slack_url = '';
const region = 'ap-northeast-1'
const codedeploy_url = 'https://' + region + '.console.aws.amazon.com/codedeploy/home?region=' + region + '#/deployments/'
const slack_req_opts = url.parse(slack_url);
slack_req_opts.method = 'POST';
slack_req_opts.headers = {'Content-Type': 'application/json'};

exports.handler = function(event, context) {
  (event.Records || []).forEach(function (rec) {
    if (rec.Sns) {
      var req = https.request(slack_req_opts, function (res) {
        if (res.statusCode === 200) {
          context.succeed('posted to slack');
        } else {
          context.fail('status code: ' + res.statusCode);
        }
      });

      req.on('error', function(e) {
        console.log('problem with request: ' + e.message);
        context.fail(e.message);
      });

      var message = JSON.parse(rec.Sns.Message);
      var str = '*' + 'Application: ' + message.applicationName + ' deploymentGroupName: ' + message.deploymentGroupName + ' deploymentId: ' + message.deploymentId + '*' + ' ' + codedeploy_url + message.deploymentId;
      req.write(JSON.stringify({text: str})); // for testing: , channel: '@vadim'

      req.end();
    }
  });
};
</code></pre>

<p><code>slack_url</code>に自前のIncoming Webhookを入れる</p>

<h2>通知される</h2>

<p><img src="https://dl.dropboxusercontent.com/u/5390179/capture-CodeDeployError.png" alt="" /></p>

<p>ご覧のとおりFail時に通知され、かつURLをクリックしたらCodeDeployのエラー画面にとべて便利なので<br/>
ご利用ください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeDeployでApplicationStopでどうしようもなくなったら]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2016/01/21/codedeploy-applicationstop-failed/"/>
    <updated>2016-01-21T17:37:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2016/01/21/codedeploy-applicationstop-failed</id>
    <content type="html"><![CDATA[<p>これやで</p>

<pre><code>$ rm -rf  /opt/codedeploy-agent/deployment-root/deployment-instructions/*
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awscliでput-metric-alarmでELBのUnHealthyHostCountUpをモニタリングして増えたりしたらアラートとばすくん]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2016/01/19/awscli-put-metric-alarm-to-elb/"/>
    <updated>2016-01-19T11:24:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2016/01/19/awscli-put-metric-alarm-to-elb</id>
    <content type="html"><![CDATA[<h2>自分用メモ</h2>

<pre><code class="rb">#!/usr/bin/env ruby

loadbalancers = `aws elb describe-load-balancers | jq '.[][]["LoadBalancerName"]' -r `
alert_sns = "SNS"

loadbalancers.each_line do |lb|
  lb.chomp!
  p lb
`aws cloudwatch put-metric-alarm --alarm-name "#{lb} UnHealthyHostCountUp" --alarm-description "#{lb} ELB UnHealthyHostCountUp" \
  --actions-enabled \
  --ok-actions #{alert_sns} \
  --alarm-actions #{alert_sns} \
  --insufficient-data-actions #{alert_sns} \
  --metric-name "UnHealthyHostCount" \
  --namespace AWS/ELB \
  --statistic Maximum\
  --dimensions Name=LoadBalancerName,Value=#{lb} \
  --period 60 \
  --evaluation-periods 5 \
  --threshold 1 \
  --comparison-operator GreaterThanOrEqualToThreshold`
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Route53を利用したフェイルオーバーシステムの作成]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2014/06/06/route53-healthcheck-failover/"/>
    <updated>2014-06-06T00:04:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2014/06/06/route53-healthcheck-failover</id>
    <content type="html"><![CDATA[<p>AWSのRoute53サービスを利用し、冗長構成のあるシステムをつくる。</p>

<h2>TL;DR</h2>

<p>同一のレコードをPrimaryとSecondaryで作成し<br/>
Primary、SecondaryそれぞれでHealth Check to Associateを設定する。<br/>
PrimaryのHealth Checkが失敗した場合、Secondaryに遷移する。<br/>
SecondaryもダメだったらPrimaryに変わる。<br/>
両方同じタイミングでダメになったらPrimaryのまま。</p>

<h2>手順</h2>

<h3>Health Checkの設定</h3>

<h5>1. <em>Health Checks</em> にてヘルスチェック対象のホスト・サービスを設定</h5>

<h3>Health Checkを利用するレコードの作成</h3>

<h5>2-1. <em>Hosted Zones</em> にてフェイルオーバーを行いたいDNSを設定</h5>

<h5>2-2. <em>Create Record Set</em> にてレコードの作成(Primary)</h5>

<h5>2-3. <em>Routing Policy</em> にて <code>Failover</code> を選択</h5>

<h5>2-4. <em>Failover Record Type</em> にて <em>Primary</em> を選択</h5>

<h5>2-5. <em>Associate with Health Check</em> にて <em>Yes</em> を選択</h5>

<h5>2-6. <em>Health Check to Associate</em> にて 1. で作成したヘルスチェックを選択</h5>

<h5>2-7. <em>Create Record Set</em> にてレコードの作成(Secondary)</h5>

<h5>2-8. <em>Routing Policy</em> にて <code>Failover</code> を選択</h5>

<h5>2-9. <em>Failover Record Type</em> にて <em>Secondary</em> を選択</h5>

<h5>2-10. <em>Associate with Health Check</em> にて <em>Yes</em> を選択</h5>

<h5>2-11. <em>Health Check to Associate</em> にて 1. で作成したヘルスチェックを選択</h5>

<p>２つの同じレコードを作成し、応答するレコードをそれぞれ<br/>
Primary, Secondaryと指定することでフェイルオーバーする仕組み。</p>

<blockquote><p>www.example.com:80</p>

<p>  => Primary
   hoge01.example.com:80 (health check <a href="http://hoge01.example.com">http://hoge01.example.com</a>)</p>

<p>  => Secondary
   hoge02.example.com:80 (health check <a href="http://hoge02.example.com">http://hoge02.example.com</a>)</p></blockquote>

<p>こんな構成で <em><a href="http://www.example.com_">http://www.example.com_</a> へのアクセスは通常だと<br/>
</em>hoge01<em> へアクセスが行くようになっていて、 </em>hoge01<em> の<br/>
レスポンスに異常があった場合に </em>hoge02_ へ行くようになる。</p>

<p>試しに ヘルスチェックを <em>tcp:24224</em> にしても問題なく認識したので<br/>
fluentdの集約サーバを冗長構成にしておいて</p>

<blockquote><p>log.example.com:24224</p>

<p>  => Primary
   hoge01.example.com (health check tcp://hoge01.example.com:24224)</p>

<p>  => Secondary
   hoge02.example.com (health check tcp://hoge02.example.com:24224)</p></blockquote>

<p>通常は <em>hoge01</em> にて集約し、メンテナンスなど<br/>
行いたい場合に <em>hoge01</em> のfluentdを落としたら、自動的に<br/>
レコードが切り替わり、 <em>hoge02</em> の方へログが流れていくような構成が組めたりする。<br/>
<em>hoge01</em> のfluentd を立ち上げるとPrimaryが正常になったことが認識され<br/>
レコードは元の <em>hoge01</em> へ向き直る。</p>

<p>SPOFをなるべくなくしていきたいので、この機能は役立ちそうだ。</p>
]]></content>
  </entry>
  
</feed>

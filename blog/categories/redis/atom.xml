<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | さよならインターネット]]></title>
  <link href="http://blog.kenjiskywalker.org/blog/categories/redis/atom.xml" rel="self"/>
  <link href="http://blog.kenjiskywalker.org/"/>
  <updated>2015-02-07T17:50:11+09:00</updated>
  <id>http://blog.kenjiskywalker.org/</id>
  <author>
    <name><![CDATA[kenjiskywalker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redisの2.8.2からsplit brainの対策がされているようです]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2014/03/12/redis-2-8-sentinel-split-brain/"/>
    <updated>2014-03-12T01:46:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2014/03/12/redis-2-8-sentinel-split-brain</id>
    <content type="html"><![CDATA[<p>2.8.2 [FIX] Sentinel better desynchronization to avoid split-brain elections
<a href="https://github.com/antirez/redis/blob/2.8/00-RELEASENOTES#L149">https://github.com/antirez/redis/blob/2.8/00-RELEASENOTES#L149</a></p>

<p>Sentinel: better time desynchronization.
<a href="https://github.com/antirez/redis/commit/75347ada7f431925b97b037b56b5e3801e3fd16d">https://github.com/antirez/redis/commit/75347ada7f431925b97b037b56b5e3801e3fd16d</a></p>

<blockquote><p>Sentinels are now desynchronized in a better way changing the time
handler frequency between 10 and 20 HZ. This way on average a
desynchronization of 25 milliesconds is produced that should be larger
enough compared to network latency, avoiding most split-brain condition
during the vote.</p>

<p>Now that the clocks are desynchronized, to have larger random delays when
performing operations can be easily achieved in the following way.
Take as example the function that starts the failover, that is
called with a frequency between 10 and 20 HZ and will start the
failover every time there are the conditions. By just adding as an
additional condition something like rand()%4 == 0, we can amplify the
desynchronization between Sentinel instances easily.</p></blockquote>

<p>こちらからは以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis Sentinelを動かしてみた]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2013/01/24/redis-sentiel-howto/"/>
    <updated>2013-01-24T16:13:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2013/01/24/redis-sentiel-howto</id>
    <content type="html"><![CDATA[<p>以前、<a href="http://blog.kenjiskywalker.org/blog/2013/01/15/redis-sentinel/">Redis Sentinelを試す</a>というエントリーを書きましたが<br/>
もう少し入り込んで検証してみた。</p>

<p>殴り書きの域を出ていないので適時アップデートしていきたい。</p>

<h2>検証環境</h2>

<ul>
<li>DATE: 2013/01/25</li>
<li>CentOS 6.3</li>
<li>Redis 2.6.9(remi)</li>
</ul>


<h2>ドキュメント</h2>

<p><a href="http://redis.io/topics/sentinel">http://redis.io/topics/sentinel</a></p>

<p>こちらを参考に行います。</p>

<h2>Sentinelの設定、および起動方法</h2>

<pre><code>$ /usr/local/bin/redis-server /etc/sentinel.conf --sentinel
[28498] 25 Jan 01:28:24.447 * Max number of open files set to 10032
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 2.6.9 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 28498
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

[28498] 25 Jan 01:28:24.451 * +slave slave 192.168.2.102:6379 192.168.2.102 6379 @ mymaster 192.168.2.101 6379
[28498] 25 Jan 01:28:25.358 * +sentinel sentinel 192.168.2.101:26379 192.168.2.101 26379 @ mymaster 192.168.2.101 6379
</code></pre>

<p>こんな感じで起動します。</p>

<h4>設定ファイル</h4>

<p>参考: <a href="http://download.redis.io/redis-stable/sentinel.conf">http://download.redis.io/redis-stable/sentinel.conf</a></p>

<pre><code>sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 900000
sentinel can-failover mymaster yes
sentinel parallel-syncs mymaster 1
</code></pre>

<p>オフィシャルの設定ファイルを参考に。</p>

<h4>設定の意味</h4>

<ul>
<li><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code></li>
</ul>


<p>この<code>&lt;quorum&gt;</code>は<em>Redis-Sentinelの数</em>を指します。<br/>
Redis-Sentinelは、他のRedis-Sentinelが接続してきた場合に<br/>
相互に理解する働きがあります。<br/>
この機能によって<em>Split-brain-syndrome</em>を防ぐことが可能です。</p>

<h4>Redisのレプリケーションが正常に行えている状態</h4>

<p><img src="https://dl.dropbox.com/u/5390179/Redis1.png" alt="正常" /></p>

<h4>Redisのレプリケーションの回線に障害が発生した場合</h4>

<p><img src="https://dl.dropbox.com/u/5390179/Redis2.png" alt="突然の" /></p>

<p>上記のように、レプリケーションの経路に異常が発生した場合<br/>
<em>Split-brain-syndrome</em>が起こり</p>

<p><img src="https://dl.dropbox.com/u/5390179/Redis3.png" alt="スプリットブレイン" /></p>

<p>レプリケーション情報は保てなくなり、お互いがMasterと認識してしまう問題があります。</p>

<p>上記のような状況を避ける為に<code>&lt;quorum&gt;</code>の設定があります。<br/>
このquorumの値は、<strong><em>監視しているRedis-Sentinelの数</em></strong>を表しています。</p>

<p>上記のようにレプリケーションの経路に異常があった場合であっても<br/>
<code>&lt;quorum&gt;</code>で設定した数のSentinelが異常を検知して初めてフェイルオーバーが始まります。<br/>
SentinelはSentinel同士で理解し合う機能が搭載されているんですね。<br/>
人間にもそんな機能があったら争いとかなくなりますかね。</p>

<h4>Redis-Sentinelの連絡が行えなくなり、Split-brain-syndromeは起こらない</h4>

<p><img src="https://dl.dropbox.com/u/5390179/Redis4.png" alt="スプリットブレイン" /></p>

<p>ということで、<code>&lt;quorum&gt;</code>を2台以上設定することで、<br/>
予期しないフェイルオーバーを予防することが可能です。</p>

<ul>
<li><code>sentinel down-after-milliseconds mymaster 60000</code></li>
</ul>


<p>SentinelがDOWNを検知してからのフェイルオーバーを始めるまでのアイドル時間。</p>

<blockquote><p>DOWNと認める条件は<a href="http://redis.io/topics/sentinel">ドキュメント</a>を参照。<br/>
<em>ODOWN</em>と<em>SDOWN</em>についてももう少し書きたい。</p></blockquote>

<p>検証時では <em>5000milliseconds</em> ぐらいが問題なく動作した。<br/>
スペックや環境によってはもっとストイックな設定が可能。</p>

<p>なお、実際にMasterが切り替わるまで <em>5~15秒</em> の間でランダムな待ち時間が発生する。</p>

<blockquote><p>Sentinel Rule #14: A Sentinel detects a failover as an Observer
(that is, the Sentinel just follows the failover generating the appropriate events in the log file and Pub/Sub interface,
 but without actively reconfiguring instances) if the following conditions are true at the same time: * There is no failover already in progress.
* A slave instance of the monitored master turned into a master.
However the failover will NOT be sensed as started if the slave instance turns into a master and at the same time the runid has changed from the previous one.
This means the instance turned into a master because of a restart, and is not a valid condition to consider it a slave election.</p>

<p>Sentinel Rule #15: A Sentinel starting a failover as leader does not immediately starts it.
It enters a state called wait-start, that lasts a random amount of time between 5 seconds and 15 seconds.
During this time Sentinel Rule #14 still applies: if a valid slave promotion is detected the failover as leader is aborted and the failover as observer is detected.</p></blockquote>

<p>詳細は<a href="http://redis.io/topics/sentinel">ドキュメント</a>の <em>Sentinel Rule #14,#15</em> を参照。</p>

<p>なので、フェイルオーバーが開始されるタイミングは<br/>
 <strong><em>down-after-milliseconds + 5~15秒</em></strong> の時間になります。</p>

<ul>
<li><code>sentinel failover-timeout mymaster 900000</code></li>
</ul>


<p>フェイルオーバーを開始してから、レスポンスが返ってくるまでの<br/>
待ち時間。詳細はやはりドキュメントを読んでほしい。</p>

<blockquote><p>検証時に &ldquo;10 milliseconds&rdquo; などストイックな設定を行なってみたが
タイムアウトに引っかかり、レプリケーションが開始することはなかった&hellip;
こちらもやはり &ldquo;5000 milliseconds&rdquo; ぐらいが安全であった</p></blockquote>

<ul>
<li><code>sentinel can-failover mymaster yes</code></li>
</ul>


<p><em>mymaster</em>のダウン時に、フェイルオーバーを実行するか否かの設定。</p>

<ul>
<li><code>sentinel parallel-syncs mymaster 1</code></li>
</ul>


<p>フェイルオーバーが実行された後、新しいマスターを<br/>
使用するように並列で再構成することができるスレーブの数の指定。</p>

<p>Slaveサーバが多く、この設定数が低いほど、<br/>
フェイルオーバーの処理に時間がかかるとのこと。<br/>
(未検証)</p>

<h2>おまけ：レプリケーションの構築手順</h2>

<h3>Slave(192.168.2.102)</h3>

<pre><code>$ echo "slaveof 192.168.2.101 6379" | redis-cli -h 192.168.2.102
OK
$
$ redis-cli -h 192.168.2.102 info | grep -E 'mas|sla'
role:slave
master_host:192.168.2.101
master_port:6379
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_priority:100
slave_read_only:1
connected_slaves:0
$
</code></pre>

<h3>Master(192.168.2.101)</h3>

<pre><code>$ redis-cli -h 192.168.2.101 info | grep -E 'mas|sla'
role:master
connected_slaves:1
slave0:192.168.2.102,6379,online
$
</code></pre>

<h3>レプリケーションの情報</h3>

<ul>
<li><p><code>master_host:192.168.2.101</code><br/>
MasterのIPアドレス情報</p></li>
<li><p><code>master_port:6379</code><br/>
MasterのPort番号情報</p></li>
<li><p><code>master_link_status:up</code><br/>
Masterの状態の情報</p></li>
<li><p><code>master_last_io_seconds_ago</code><br/>
Slaveは10秒間隔でMasterへ<em>PING</em>を送信している。<br/>
その&#8221;正常な&#8221;データを受信してからの経過時間の情報</p></li>
</ul>


<p><code>monitor</code>コマンドで確認することができる。</p>

<pre><code>$ redis-cli -h 192.168.2.102 monitor
OK
1359037270.075903 [0 192.168.2.101:6379] "PING"
1359037280.274001 [0 192.168.2.101:6379] "PING"
1359037290.464774 [0 192.168.2.101:6379] "PING"
</code></pre>

<ul>
<li><code>master_sync_in_progress</code><br/>
Masterからデータを受信状況(SYNC)の情報<br/>
SYNC中であれば <em>1</em> のフラグが立ち、状況の詳細が表示される。</li>
</ul>


<blockquote><p>詳細はこちら : <a href="http://redis.io/commands/info">INFO / Redis</a></p></blockquote>

<h4>Masterが落ちていた場合の状態</h4>

<pre><code>master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
master_link_down_since_seconds:N
</code></pre>

<p><em>PING</em>の間隔が10秒間隔なので、疎通チェックも10秒間隔かと思うが<br/>
そうではない(もう少し調べる)。</p>

<h2>おまけのおまけ</h2>

<h4>SlaveのSlaveも設定可能</h4>

<p><code>101.slave(Master) &lt;= 102.6379(Slave) &lt;= 102.6380(Slave)</code></p>

<pre><code>$ redis-cli -h 192.168.2.102 info | grep -E 'mas|sla'
role:slave
master_host:192.168.2.101
master_port:6379
master_link_status:up
master_last_io_seconds_ago:7
master_sync_in_progress:0
slave_priority:100
slave_read_only:1
connected_slaves:1
slave0:192.168.2.102,6380,online
$
</code></pre>

<blockquote><p>また、MasterとSlaveの接続が切れた場合も<br/>
Slave &lt;=> Slaveの同期は停止する。(検証済み)</p></blockquote>

<p>master_last_io_seconds_ago が Sentinel立ち上げる事に間隔が短かくなる<br/>
3台上げたらほとんど1秒間隔になった。</p>

<h2>ということで</h2>

<p>Sentinel、よく考えられているなという印象です。<br/>
以上、この情報が何かのお役に立てれば幸いです。</p>

<blockquote><p>This HOWTO is a work in progress, more information will be added in the near future.</p></blockquote>

<p><a href="https://github.com/antirez/redis-doc/blob/master/topics/sentinel.md">https://github.com/antirez/redis-doc/blob/master/topics/sentinel.md</a></p>

<p>ということで、活発的に開発が行われているので<br/>
適時チェックするのが良さそうですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis Sentinelを試す]]></title>
    <link href="http://blog.kenjiskywalker.org/blog/2013/01/15/redis-sentinel/"/>
    <updated>2013-01-15T19:42:00+09:00</updated>
    <id>http://blog.kenjiskywalker.org/blog/2013/01/15/redis-sentinel</id>
    <content type="html"><![CDATA[<p>某社では<a href="http://d.hatena.ne.jp/sfujiwara/20120802/1343880266">RedisをKeepalivedでフェイルオーバーする構成案 / 酒日記 はてな支店</a><br/>
みたいな構成が使われているとか使われていないとかで、Sentinelはどうなのだろうか<br/>
というお話がわいたので、カジュアルに試してみました。</p>

<p>参考：<a href="http://redis.io/topics/sentinel">Redis Sentinel Documentation</a></p>

<p><code>6379 Port が Master</code><br/>
<code>6380 Port が 6379のSlave</code></p>

<p>上記内容のRedisのセットがあるとします。</p>

<pre><code>[hoge@example ~]# 
[hoge@example ~]# redis-cli -p 6379 info | grep role -3
latest_fork_usec:340

# Replication
role:master
connected_slaves:1
slave0:127.0.0.1,6380,online

[hoge@example ~]# redis-cli -p 6380 info | grep role -3
latest_fork_usec:336

# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
[hoge@example ~]# 
</code></pre>

<p><code>sentinel.conf</code>はソースファイルから拾ってくるのでも良いし<br/>
参考サイトからコピペするでも良いかと。</p>

<pre><code>[hoge@example ~]# cat /etc/sentinel.conf 
sentinel monitor mymaster 127.0.0.1 6379 1
sentinel down-after-milliseconds mymaster 10000
sentinel failover-timeout mymaster 50000
sentinel can-failover mymaster yes
sentinel parallel-syncs mymaster 1
[hoge@example ~]# 
[hoge@example ~]# 
[hoge@example ~]# redis-server /etc/sentinel.conf --sentinel
[8373] 15 Jan 19:44:27.071 * Max number of open files set to 10032
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 2.6.8 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 8373
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

[8373] 15 Jan 19:44:27.078 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379

 --- 動きました --
</code></pre>

<pre><code> ...

  ＿人人人人人人人人人＿
  ＞  Master突然の死  ＜
  ￣Y^Y^Y^Y^Y^Y^Y^Y￣
</code></pre>

<pre><code> ...

[8373] 15 Jan 19:45:41.854 # +sdown master mymaster 127.0.0.1 6379 6380 @ mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:41.854 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1
[8373] 15 Jan 19:45:41.855 # +failover-triggered master mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:41.855 # +failover-state-wait-start master mymaster 127.0.0.1 6379 #starting in 6893 milliseconds

ログがゴニョゴニョ出てきて

[8373] 15 Jan 19:45:48.750 # +failover-state-select-slave master mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:48.851 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:48.852 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:48.953 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:48.954 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:48.954 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:49.054 # +failover-end master mymaster 127.0.0.1 6379
[8373] 15 Jan 19:45:49.054 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380

マスター変わったよーというログが出ていますね
</code></pre>

<p>Redisのレプリケーションの状況を確認</p>

<pre><code>[hoge@example ~]# 
[hoge@example ~]# redis-cli -p 6379 info | grep role -3
Could not connect to Redis at 127.0.0.1:6379: Connection refused
[hoge@example ~]# 
[hoge@example ~]# redis-cli -p 6380 info | grep role -3
latest_fork_usec:336

# Replication
role:master
connected_slaves:0

# CPU
[hoge@example ~]# 
</code></pre>

<p><code>6380 PortのRedis</code>がMasterになっていますね。</p>

<p>とてもシンプルにfailoverが可能であることがわかりました。</p>

<blockquote><p>この設定だけでは<code>Master &lt;=&gt; Slave</code>間で障害が発生した場合など<br/>
諸所問題点があるので、ちょっと工夫が必要。</p></blockquote>

<p>その他ドキュメントを読んでて気付いたところ</p>

<ul>
<li><p><code>sentinel parallel-syncs hoge 1</code> hogeがMasterに切り替わった時にslave化する数。あんまり増やすとデータの同期取ったりすることに時間がかかるよとのこと。</p></li>
<li><p><code>SDOWN(主体的ダウン検知)</code>、<code>ODOWN(客観的ダウン検知)</code>の2つのパターンがあり、それぞれの状態を観察しているのが面白い</p></li>
</ul>


<p>基本的に1ページによくまとまっていて、<code>Sentinel Rule</code>を読むことで<br/>
どのような状態になった時に、どうのような状態に遷移させる。<br/>
判断基準としてはこれとこれを見ている。</p>

<p>などなど、シンプルかつ丁寧に書かれており、とても読みやすい印象でした。</p>
]]></content>
  </entry>
  
</feed>
